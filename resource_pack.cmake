include_guard(GLOBAL)

# The main entrypoint function to resource_pack. This function embeds an input file inside a target's binary. This works
# for all target types that produce binaries: static libraries, dynamic libraries and executables. Note that it uses
# highly platform-specific methods, such as Linux linker arguments and Windows resources API, so it may not work for all
# platforms unless explicitly supported.
#
# The group name argument is a custom user-defined name for a group of resources embedded in the binary. A target can
# have multiple resource groups. A single group name can only be used by a single target (globally in the whole project).
# All resources within the group are be exposed in a single interface header. This function sets up target's include
# directories, so the header can be accessed as:
#    #include "resource_pack/<GROUP_NAME>/<GROUP_NAME>.h
#
# The interface header, along with any generated intermediate files, will be put under <BINARY_DIR>/resource_pack
# directory. To make the project look nice in IDEs, resource_pack remembers all generated files as well as input files
# and offers a resource_pack_set_source_group() function that makes appropriate source_group calls. It's recommended to
# call this function when using resource_pack.
function(resource_pack_add TARGET GROUP_NAME IN_FILE)
    # Prepare filenames
    if (NOT IS_ABSOLUTE "${IN_FILE}")
        message(FATAL_ERROR "resource_pack: input files must be absolute paths. Passed: ${IN_FILE}")
    endif ()
    get_filename_component(RESOURCE_NAME ${IN_FILE} NAME_WE) # We could allow a custom name, but let's just use the stem
    resource_pack_get_out_dir(OUT_DIR "${GROUP_NAME}")
    get_filename_component(ROOT_DIR "${OUT_DIR}/../.." REALPATH)

    # Prepare the string that we will put at the beginning of each generated C++ file.
    set(PREAMBLE_COMMENT "// This is a file generated by resource_pack. Do not modify it manually.\n//\n//\n\n")

    # Check if it's the first time we are called and if it's the first time we see this group.
    set(GROUPS_PROPERTY_NAME "RESOURCE_PACK_groups")
    set(GROUP_TARGET_PROPERTY_NAME "RESOURCE_PACK_target_${GROUP_NAME}")
    get_property(RESOURCE_PACK_GROUPS GLOBAL PROPERTY "${GROUPS_PROPERTY_NAME}")
    if ("${RESOURCE_PACK_GROUPS}d" STREQUAL "d")
        set(IS_RESOURCE_PACK_INIT TRUE)
    else ()
        set(IS_RESOURCE_PACK_INIT FALSE)
    endif ()
    list(FIND RESOURCE_PACK_GROUPS "${GROUP_NAME}" HEADER_INDEX)
    if (HEADER_INDEX EQUAL -1)
        set(IS_GROUP_INIT TRUE)

        list(APPEND RESOURCE_PACK_GROUPS "${GROUP_NAME}")
        set_property(GLOBAL PROPERTY "${GROUPS_PROPERTY_NAME}" "${RESOURCE_PACK_GROUPS}")
        set_property(GLOBAL PROPERTY "${GROUP_TARGET_PROPERTY_NAME}" "${TARGET}")

        message(STATUS "resource_pack: initializing ${GROUP_NAME} resource group for target ${TARGET}")
    else ()
        set(IS_GROUP_INIT FALSE)

        get_property(PREVIOUS_GROUP_TARGET GLOBAL PROPERTY "${GROUP_TARGET_PROPERTY_NAME}")
        if (NOT "${PREVIOUS_GROUP_TARGET}" STREQUAL "${TARGET}")
            message(FATAL_ERROR "resource_pack: group ${GROUP} was used for multiple targets: ${PREVIOUS_GROUP_TARGET} and ${TARGET}")
        endif ()
    endif ()

    # Add input file to the target
    resource_pack_register_file(${GROUP_NAME} ${TARGET} PUBLIC ${IN_FILE})

    # We're going to generate all our files including the interface header to OUT_DIR. Add its grandparent directory to
    # include dirs, so that includes look like #include " resource_pack/XXX.h".
    if (IS_GROUP_INIT)
        target_include_directories(${TARGET} PUBLIC "${ROOT_DIR}")
    endif ()

    # Generate a file with EmbeddedResource struct definition.
    set(COMMON_HEADER_FILE "${ROOT_DIR}/resource_pack/resource_pack.h")
    if (IS_RESOURCE_PACK_INIT)
        file(WRITE "${COMMON_HEADER_FILE}" "${PREAMBLE_COMMENT}")
        file(APPEND "${COMMON_HEADER_FILE}" "#pragma once\n\n")
        file(APPEND "${COMMON_HEADER_FILE}" "#include <cstddef>\n\n")
        file(APPEND "${COMMON_HEADER_FILE}" "struct EmbeddedResource {\n    const void *data;\n    size_t size;\n};\n")
    endif ()

    # Generate an interface .h file. This file will be include by the client code.
    set(INTERFACE_HEADER_FILE_NAME "${GROUP_NAME}.h")
    set(INTERFACE_HEADER_FILE "${OUT_DIR}/${INTERFACE_HEADER_FILE_NAME}")
    if (IS_GROUP_INIT)
        file(WRITE "${INTERFACE_HEADER_FILE}" "${PREAMBLE_COMMENT}")
        file(APPEND "${INTERFACE_HEADER_FILE}" "#pragma once\n\n")
        file(APPEND "${INTERFACE_HEADER_FILE}" "#include \"resource_pack/resource_pack.h\"\n\n")
        resource_pack_register_file(${GROUP_NAME} ${TARGET} PUBLIC ${INTERFACE_HEADER_FILE})
    endif ()
    file(APPEND "${INTERFACE_HEADER_FILE}" "extern const EmbeddedResource &${RESOURCE_NAME};\n")

    # OS specific generation
    if (UNIX)
        # On Unix system we will generate an ELF object file per resource with a special ld argument. Such object
        # files contain the binary data embedded in them along with two symbols for start and end addresses. They
        # have some kind of weird semantics and must be defined as arrays and not pointers for some reason. We link
        # all these object files into our target executable.

        # Generate the object file
        get_filename_component(IN_FILE_DIR ${IN_FILE} DIRECTORY)
        get_filename_component(IN_FILE_NAME ${IN_FILE} NAME)
        set(OBJECT_FILE "${OUT_DIR}/detail/${IN_FILE_NAME}.o")
        add_custom_command(
            DEPENDS ${IN_FILE}
            OUTPUT ${OBJECT_FILE}
            COMMAND ld ARGS -r -b binary -z noexecstack "${IN_FILE_NAME}" -o "${OBJECT_FILE}"
            WORKING_DIRECTORY "${IN_FILE_DIR}"
            COMMENT "Compiling resource to object file ${IN_FILE} -> ${OBJECT_FILE}"
        )

        # Link the object file to the target
        resource_pack_register_file(${GROUP_NAME} ${TARGET} PRIVATE ${OBJECT_FILE})

        # Generate an interface .cpp file
        string(REPLACE "." "_" IN_FILE_NAME_UNDERSCORES "${IN_FILE_NAME}")
        set(SYMBOL_NAME_START "_binary_${IN_FILE_NAME_UNDERSCORES}_start")
        set(SYMBOL_NAME_END "_binary_${IN_FILE_NAME_UNDERSCORES}_end")
        set(OUT_INTERFACE_IMPL "${OUT_DIR}/detail/${GROUP_NAME}.cpp")
        if (IS_GROUP_INIT)
            file(WRITE "${OUT_INTERFACE_IMPL}" "${PREAMBLE_COMMENT}")
            file(APPEND "${OUT_INTERFACE_IMPL}" "#include \"resource_pack/${GROUP_NAME}/${INTERFACE_HEADER_FILE_NAME}\"\n\n")
            resource_pack_register_file(${GROUP_NAME} ${TARGET} PRIVATE ${OUT_INTERFACE_IMPL})
        endif ()
        file(APPEND "${OUT_INTERFACE_IMPL}" "const extern unsigned char ${SYMBOL_NAME_START}[];\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "const extern unsigned char ${SYMBOL_NAME_END}[];\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "const static EmbeddedResource storage_${RESOURCE_NAME}(${SYMBOL_NAME_START}, ${SYMBOL_NAME_END} - ${SYMBOL_NAME_START});\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "const EmbeddedResource& ${RESOURCE_NAME} = storage_${RESOURCE_NAME};\n\n")
    elseif (WIN32)
        # On Windows we have to use the mechanism of embedding resources into PE files. First we have to generate an
        # .rc file and link it to the target executable. Internally it will be compiled into a .res file with rc
        # (resource compiler) and this will be actually linked. That's not important to understand this, though. This
        # whole process causes the linker to embed the binaries inside the executable. Then, at runtime we have to use
        # WinApi to retrieve the binaries.

        # Get the list of all resource names in this group
        set(RESOURCES_PROPERTY "RESOURCE_PACK_resources_${GROUP_NAME}")
        get_property(RESOURCES GLOBAL PROPERTY ${RESOURCES_PROPERTY})
        list(APPEND RESOURCES "${RESOURCE_NAME}")
        set_property(GLOBAL PROPERTY ${RESOURCES_PROPERTY} "${RESOURCES}")

        # Get unique integer ID for this resource
        get_property(CURRENT_RESOURCE_ID GLOBAL PROPERTY RESOURCE_PACK_resource_id)
        if (NOT CURRENT_RESOURCE_ID)
            set(CURRENT_RESOURCE_ID "1000")
        endif ()
        math(EXPR CURRENT_RESOURCE_ID "${CURRENT_RESOURCE_ID} + 1")
        set_property(GLOBAL PROPERTY RESOURCE_PACK_resource_id "${CURRENT_RESOURCE_ID}")

        # Generate a header file with resource IDs. It will be included in .rc and in .cpp.
        set(ID_FILE_NAME "${GROUP_NAME}_res_ids.h")
        set(ID_FILE "${OUT_DIR}/${ID_FILE_NAME}")
        if (IS_GROUP_INIT)
            file(WRITE "${ID_FILE}" "${PREAMBLE_COMMENT}")
            resource_pack_register_file(${GROUP_NAME} ${TARGET} PUBLIC ${ID_FILE})
        endif ()
        file(APPEND "${ID_FILE}" "#define RES_ID_${RESOURCE_NAME} ${CURRENT_RESOURCE_ID}\n")

        # Generate an .rc file describing the resources and link into into the executable
        set(RC_FILE "${OUT_DIR}/${GROUP_NAME}.rc")
        if (IS_GROUP_INIT)
            file(WRITE "${RC_FILE}" "${PREAMBLE_COMMENT}")
            file(APPEND "${RC_FILE}" "#include \"resource_pack/${GROUP_NAME}/${ID_FILE_NAME}\"\n\n")
            resource_pack_register_file(${GROUP_NAME} ${TARGET} PUBLIC ${RC_FILE})
        endif ()
        file(APPEND "${RC_FILE}" "RES_ID_${RESOURCE_NAME} RCDATA ${IN_FILE}\n")

        # Generate an interface .cpp file
        set(OUT_INTERFACE_IMPL "${OUT_DIR}/detail/${GROUP_NAME}.cpp")
        file(WRITE "${OUT_INTERFACE_IMPL}" "${PREAMBLE_COMMENT}")
        file(APPEND "${OUT_INTERFACE_IMPL}" "#include \"resource_pack/${GROUP_NAME}/${INTERFACE_HEADER_FILE_NAME}\"\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "#include \"resource_pack/${GROUP_NAME}/${ID_FILE_NAME}\"\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "#include <Windows.h>\n\n")
        foreach (RES_NAME IN LISTS RESOURCES)
            file(APPEND "${OUT_INTERFACE_IMPL}" "static EmbeddedResource storage_${RES_NAME};\n")
        endforeach ()
        file(APPEND "${OUT_INTERFACE_IMPL}" "\n")
        foreach (RES_NAME IN LISTS RESOURCES)
            file(APPEND "${OUT_INTERFACE_IMPL}" "const EmbeddedResource &${RES_NAME} = storage_${RES_NAME};\n")
        endforeach ()
        file(APPEND "${OUT_INTERFACE_IMPL}" "\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "static void loadResource(WORD resId, EmbeddedResource *outResource) {\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "    HRSRC res = FindResource(nullptr, MAKEINTRESOURCE(resId), RT_RCDATA);\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "    HGLOBAL h = LoadResource(nullptr, res);\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "    void* data = LockResource(h);\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "    size_t size = SizeofResource(nullptr, res);\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "    *outResource = { data, size };\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "}\n\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "struct LoadAtInit_${GROUP_NAME} {\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "    LoadAtInit_${GROUP_NAME}() {\n")
        set(IDX 0)
        foreach (RES_NAME IN LISTS RESOURCES)
            math(EXPR IDX "${IDX} + 1")
            file(APPEND "${OUT_INTERFACE_IMPL}" "        loadResource(RES_ID_${RES_NAME}, &storage_${RES_NAME});\n")
        endforeach ()
        file(APPEND "${OUT_INTERFACE_IMPL}" "    }\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "};\n")
        file(APPEND "${OUT_INTERFACE_IMPL}" "static const LoadAtInit_${GROUP_NAME} loadAtInit_${GROUP_NAME}{};\n")
        if (IS_GROUP_INIT)
            resource_pack_register_file(${GROUP_NAME} ${TARGET} PRIVATE ${OUT_INTERFACE_IMPL})
        endif ()
    else ()
        message(FATAL_ERROR "Not implemented")
    endif ()
endfunction()

# A convenience function that calls resource_pack_add() for all files in a given directory. This is a wrapper for the
# simplest case of adding any files that we can find. If the user requires a more sophisticated file selection, e.g. by
# extension or name pattern, they should implement it themselves and call resource_pack_add() directly.
function(resource_pack_add_from_dir TARGET GROUP_NAME IN_DIR)
    file(GLOB FILES "${IN_DIR}/*")
    foreach (FILE IN LISTS FILES)
        resource_pack_add(${TARGET} ${GROUP_NAME} ${FILE})
    endforeach ()
endfunction()

# Sets up source_groups for all files tracked by resource_pack. Source groups do not change anything functionally, but
# they are used by IDEs such as Visual Studio to group source files into "folders" in solution explorers. These folders
# do not necessarily reflect the filesystem locations, but serves as a logical grouping. It is recommended to call this
# function once per resource group after all resources are registered to make it appear neatly logically grouped in
# editors like Visual studio.
#
# The user is allowed to select their own source group name to make it fit into the project. It can be the same as group
# name itself, but it could be different, e.g. "res/<GROUP_NAME>" would be nice if there are a lot of groups.
#
# Note that this function must be called in the same CMake directory that created the target of this group, i.e. the
# same directory were add_executable or add_library calls were made. Otherwise it will have no effect. This is a CMake
# requirement.
function(resource_pack_set_source_group GROUP_NAME SOURCE_GROUP_NAME)
    get_property(FILES_PUBLIC GLOBAL PROPERTY "RESOURCE_PACK_files_${GROUP_NAME}_PUBLIC")
    get_property(FILES_PRIVATE GLOBAL PROPERTY "RESOURCE_PACK_files_${GROUP_NAME}_PRIVATE")

    source_group(${SOURCE_GROUP_NAME} FILES ${FILES_PUBLIC})
    source_group(${SOURCE_GROUP_NAME}/detail FILES ${FILES_PRIVATE})
endfunction()

# This function generally doesn't need to be called and for the most part it's used internally by resource_pack. It adds
# a given file to target sources and stores it in a global property to allow resource_pack_set_source_group() access it.
# Note this function does not embed the file in the target binary. Use resource_pack_add() for that. This function does
# not change anything functionally and can be optionally used to make certain files show in an IDE nicely.
#
# An example usage would be if a file embedded with resource_pack_add() was itself generated from a different file. E.g.
# a GLSL shader was compiled to SPIR-V. The SPIR-V should be embedded with resource_pack_register_file(). Optionally the
# source GLSL file could be registered with resource_pack_register_file(), so that it shows in an IDE like Visual Studio.
function(resource_pack_register_file GROUP_NAME TARGET SCOPE FILE_ABS)
    target_sources(${TARGET} ${SCOPE} "${FILE_ABS}")
    set(PROPERTY_NAME "RESOURCE_PACK_files_${GROUP_NAME}_${SCOPE}")

    get_property(FILE_LIST GLOBAL PROPERTY "${PROPERTY_NAME}")
    if (NOT FILE_LIST)
        set(FILE_LIST "")
    endif ()

    list(APPEND FILE_LIST "${FILE_ABS}")
    set_property(GLOBAL PROPERTY "${PROPERTY_NAME}" "${FILE_LIST}")
endfunction()

# This function generally doesn't need to be called and for the most part it's used internally by resource_pack. It
# returns a directory used for all intermediate files generated internally by resource_pack. A user may wish to call
# this function if they're generating input files themselves and would like to put them all in one location with other
# generated artifacts.
function(resource_pack_get_out_dir OUT_VAR GROUP_NAME)
    set(OUT_DIR "${CMAKE_BINARY_DIR}/resource_pack/resource_pack/${GROUP_NAME}")
    file(MAKE_DIRECTORY ${OUT_DIR}/detail)
    set(${OUT_VAR} "${OUT_DIR}" PARENT_SCOPE)
endfunction()
